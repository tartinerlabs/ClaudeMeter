name: Release

on:
  release:
    types: [published]

env:
  APP_NAME: ClaudeMeter
  SCHEME: ClaudeMeter
  SPARKLE_VERSION: "2.8.1"

jobs:
  build-and-release:
    runs-on: macos-15
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read version from xcconfig
        id: version
        run: |
          VERSION=$(grep 'MARKETING_VERSION' Config/Version.xcconfig | cut -d'=' -f2 | tr -d ' ')
          BUILD_NUMBER=$(grep 'CURRENT_PROJECT_VERSION' Config/Version.xcconfig | cut -d'=' -f2 | tr -d ' ')
          TAG_VERSION=${GITHUB_REF_NAME#v}

          if [ "$VERSION" != "$TAG_VERSION" ]; then
            echo "::error::Tag version ($TAG_VERSION) does not match xcconfig version ($VERSION)"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Update version in project
        run: |
          sed -i '' "s/MARKETING_VERSION = .*;/MARKETING_VERSION = ${{ steps.version.outputs.version }};/g" ${{ env.APP_NAME }}.xcodeproj/project.pbxproj
          sed -i '' "s/CURRENT_PROJECT_VERSION = .*;/CURRENT_PROJECT_VERSION = ${{ steps.version.outputs.build_number }};/g" ${{ env.APP_NAME }}.xcodeproj/project.pbxproj

      - name: Build and archive
        run: |
          xcodebuild -project ${{ env.APP_NAME }}.xcodeproj \
            -scheme ${{ env.SCHEME }} \
            -configuration Release \
            -archivePath build/${{ env.APP_NAME }}.xcarchive \
            archive \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

      - name: Export app
        run: |
          mkdir -p build/export
          cp -R "build/${{ env.APP_NAME }}.xcarchive/Products/Applications/${{ env.APP_NAME }}.app" build/export/

      - name: Create zip
        run: |
          cd build/export
          zip -r -y ../${{ env.APP_NAME }}.zip ${{ env.APP_NAME }}.app

      - name: Download Sparkle
        run: |
          curl -L -o sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/${{ env.SPARKLE_VERSION }}/Sparkle-${{ env.SPARKLE_VERSION }}.tar.xz"
          mkdir -p sparkle
          tar -xf sparkle.tar.xz -C sparkle

      - name: Sign update and generate appcast
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p releases
          cp build/${{ env.APP_NAME }}.zip releases/

          if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
            # Sign the zip with EdDSA and generate appcast manually (generate_appcast requires Apple code signing)
            # sign_update outputs: sparkle:edSignature="..." length="..."
            # We need to extract just the signature value
            SIGN_OUTPUT=$(echo "$SPARKLE_PRIVATE_KEY" | ./sparkle/bin/sign_update build/${{ env.APP_NAME }}.zip --ed-key-file -)
            echo "sign_update output: $SIGN_OUTPUT"
            SIGNATURE=$(echo "$SIGN_OUTPUT" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')
            if [ -z "$SIGNATURE" ]; then
              echo "::error::Failed to extract signature from sign_update output"
              exit 1
            fi
            echo "Extracted signature: $SIGNATURE"
            FILE_SIZE=$(stat -f%z build/${{ env.APP_NAME }}.zip)
            VERSION="${{ steps.version.outputs.version }}"
            BUILD="${{ steps.version.outputs.build_number }}"
            DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/${{ env.APP_NAME }}.zip"
            PUB_DATE=$(date -R)

            # Fetch release notes from GitHub and convert to HTML
            RELEASE_BODY=$(gh release view "${{ github.ref_name }}" --json body -q '.body')
            # Convert markdown to basic HTML for Sparkle display
            RELEASE_HTML=$(echo "$RELEASE_BODY" | sed \
              -e 's/^## \(.*\)/<h2>\1<\/h2>/' \
              -e 's/^### \(.*\)/<h3>\1<\/h3>/' \
              -e 's/^- \(.*\)/<li>\1<\/li>/' \
              | awk 'BEGIN{in_list=0} /<li>/{if(!in_list){print "<ul>"; in_list=1}} !/<li>/&&in_list{print "</ul>"; in_list=0} {print} END{if(in_list)print "</ul>"}')

            cat > releases/appcast.xml << APPCAST_EOF
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>ClaudeMeter Updates</title>
        <link>https://github.com/${{ github.repository }}/releases</link>
        <description>Most recent updates to ClaudeMeter</description>
        <language>en</language>
        <item>
            <title>Version ${VERSION}</title>
            <pubDate>${PUB_DATE}</pubDate>
            <sparkle:version>${BUILD}</sparkle:version>
            <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
            <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
            <description><![CDATA[
${RELEASE_HTML}
            ]]></description>
            <enclosure
                url="${DOWNLOAD_URL}"
                length="${FILE_SIZE}"
                type="application/octet-stream"
                sparkle:edSignature="${SIGNATURE}" />
        </item>
    </channel>
</rss>
APPCAST_EOF

            # Move generated appcast to repo root
            mv releases/appcast.xml appcast.xml
          else
            echo "::warning::SPARKLE_PRIVATE_KEY secret not set. Skipping signing."
          fi

      - name: Upload release asset
        uses: softprops/action-gh-release@v2
        with:
          files: build/${{ env.APP_NAME }}.zip

      - name: Commit updated appcast
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add appcast.xml
          git diff --staged --quiet || git commit -m "Update appcast for ${{ github.ref_name }}"
          git push origin HEAD:main
